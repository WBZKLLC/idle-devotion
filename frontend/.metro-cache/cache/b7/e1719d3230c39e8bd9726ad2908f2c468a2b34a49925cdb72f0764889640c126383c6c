{"dependencies":[{"name":"./error.js","data":{"asyncType":null,"isESMImport":false,"locs":[{"start":{"line":3,"column":14,"index":78},"end":{"line":3,"column":35,"index":99}}],"key":"nY2/IYbpejbo9t02o6GDs6JBF78=","exportNames":["*"],"imports":1}},{"name":"./syncpromise.js","data":{"asyncType":null,"isESMImport":false,"locs":[{"start":{"line":4,"column":20,"index":121},"end":{"line":4,"column":47,"index":148}}],"key":"f6xgy5773iX0Z7Zo+aZYk4K5Wac=","exportNames":["*"],"imports":1}}],"output":[{"data":{"code":"__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n  const error = require(_dependencyMap[0], \"./error.js\");\n  const syncpromise = require(_dependencyMap[1], \"./syncpromise.js\");\n\n  /**\n   * Creates an new PromiseBuffer object with the specified limit\n   * @param limit max number of promises that can be stored in the buffer\n   */\n  function makePromiseBuffer(limit) {\n    const buffer = [];\n    function isReady() {\n      return limit === undefined || buffer.length < limit;\n    }\n\n    /**\n     * Remove a promise from the queue.\n     *\n     * @param task Can be any PromiseLike<T>\n     * @returns Removed promise.\n     */\n    function remove(task) {\n      return buffer.splice(buffer.indexOf(task), 1)[0];\n    }\n\n    /**\n     * Add a promise (representing an in-flight action) to the queue, and set it to remove itself on fulfillment.\n     *\n     * @param taskProducer A function producing any PromiseLike<T>; In previous versions this used to be `task:\n     *        PromiseLike<T>`, but under that model, Promises were instantly created on the call-site and their executor\n     *        functions therefore ran immediately. Thus, even if the buffer was full, the action still happened. By\n     *        requiring the promise to be wrapped in a function, we can defer promise creation until after the buffer\n     *        limit check.\n     * @returns The original promise.\n     */\n    function add(taskProducer) {\n      if (!isReady()) {\n        return syncpromise.rejectedSyncPromise(new error.SentryError('Not adding Promise because buffer limit was reached.'));\n      }\n\n      // start the task and add its promise to the queue\n      const task = taskProducer();\n      if (buffer.indexOf(task) === -1) {\n        buffer.push(task);\n      }\n      void task.then(() => remove(task))\n      // Use `then(null, rejectionHandler)` rather than `catch(rejectionHandler)` so that we can use `PromiseLike`\n      // rather than `Promise`. `PromiseLike` doesn't have a `.catch` method, making its polyfill smaller. (ES5 didn't\n      // have promises, so TS has to polyfill when down-compiling.)\n      .then(null, () => remove(task).then(null, () => {\n        // We have to add another catch here because `remove()` starts a new promise chain.\n      }));\n      return task;\n    }\n\n    /**\n     * Wait for all promises in the queue to resolve or for timeout to expire, whichever comes first.\n     *\n     * @param timeout The time, in ms, after which to resolve to `false` if the queue is still non-empty. Passing `0` (or\n     * not passing anything) will make the promise wait as long as it takes for the queue to drain before resolving to\n     * `true`.\n     * @returns A promise which will resolve to `true` if the queue is already empty or drains before the timeout, and\n     * `false` otherwise\n     */\n    function drain(timeout) {\n      return new syncpromise.SyncPromise((resolve, reject) => {\n        let counter = buffer.length;\n        if (!counter) {\n          return resolve(true);\n        }\n\n        // wait for `timeout` ms and then resolve to `false` (if not cancelled first)\n        const capturedSetTimeout = setTimeout(() => {\n          if (timeout && timeout > 0) {\n            resolve(false);\n          }\n        }, timeout);\n\n        // if all promises resolve in time, cancel the timer and resolve to `true`\n        buffer.forEach(item => {\n          void syncpromise.resolvedSyncPromise(item).then(() => {\n            if (! --counter) {\n              clearTimeout(capturedSetTimeout);\n              resolve(true);\n            }\n          }, reject);\n        });\n      });\n    }\n    return {\n      $: buffer,\n      add,\n      drain\n    };\n  }\n  exports.makePromiseBuffer = makePromiseBuffer;\n});","lineCount":99,"map":[[2,2,1,0,"Object"],[2,8,1,6],[2,9,1,7,"defineProperty"],[2,23,1,21],[2,24,1,22,"exports"],[2,31,1,29],[2,33,1,31],[2,45,1,43],[2,47,1,45],[3,4,1,47,"value"],[3,9,1,52],[3,11,1,54],[4,2,1,59],[4,3,1,60],[4,4,1,61],[5,2,3,0],[5,8,3,6,"error"],[5,13,3,11],[5,16,3,14,"require"],[5,23,3,21],[5,24,3,21,"_dependencyMap"],[5,38,3,21],[5,55,3,34],[5,56,3,35],[6,2,4,0],[6,8,4,6,"syncpromise"],[6,19,4,17],[6,22,4,20,"require"],[6,29,4,27],[6,30,4,27,"_dependencyMap"],[6,44,4,27],[6,67,4,46],[6,68,4,47],[8,2,6,0],[9,0,7,0],[10,0,8,0],[11,0,9,0],[12,2,10,0],[12,11,10,9,"makePromiseBuffer"],[12,28,10,26,"makePromiseBuffer"],[12,29,10,27,"limit"],[12,34,10,32],[12,36,10,34],[13,4,11,2],[13,10,11,8,"buffer"],[13,16,11,14],[13,19,11,17],[13,21,11,19],[14,4,13,2],[14,13,13,11,"isReady"],[14,20,13,18,"isReady"],[14,21,13,18],[14,23,13,21],[15,6,14,4],[15,13,14,11,"limit"],[15,18,14,16],[15,23,14,21,"undefined"],[15,32,14,30],[15,36,14,34,"buffer"],[15,42,14,40],[15,43,14,41,"length"],[15,49,14,47],[15,52,14,50,"limit"],[15,57,14,55],[16,4,15,2],[18,4,17,2],[19,0,18,0],[20,0,19,0],[21,0,20,0],[22,0,21,0],[23,0,22,0],[24,4,23,2],[24,13,23,11,"remove"],[24,19,23,17,"remove"],[24,20,23,18,"task"],[24,24,23,22],[24,26,23,24],[25,6,24,4],[25,13,24,11,"buffer"],[25,19,24,17],[25,20,24,18,"splice"],[25,26,24,24],[25,27,24,25,"buffer"],[25,33,24,31],[25,34,24,32,"indexOf"],[25,41,24,39],[25,42,24,40,"task"],[25,46,24,44],[25,47,24,45],[25,49,24,47],[25,50,24,48],[25,51,24,49],[25,52,24,50],[25,53,24,51],[25,54,24,52],[26,4,25,2],[28,4,27,2],[29,0,28,0],[30,0,29,0],[31,0,30,0],[32,0,31,0],[33,0,32,0],[34,0,33,0],[35,0,34,0],[36,0,35,0],[37,0,36,0],[38,4,37,2],[38,13,37,11,"add"],[38,16,37,14,"add"],[38,17,37,15,"taskProducer"],[38,29,37,27],[38,31,37,29],[39,6,38,4],[39,10,38,8],[39,11,38,9,"isReady"],[39,18,38,16],[39,19,38,17],[39,20,38,18],[39,22,38,20],[40,8,39,6],[40,15,39,13,"syncpromise"],[40,26,39,24],[40,27,39,25,"rejectedSyncPromise"],[40,46,39,44],[40,47,39,45],[40,51,39,49,"error"],[40,56,39,54],[40,57,39,55,"SentryError"],[40,68,39,66],[40,69,39,67],[40,123,39,121],[40,124,39,122],[40,125,39,123],[41,6,40,4],[43,6,42,4],[44,6,43,4],[44,12,43,10,"task"],[44,16,43,14],[44,19,43,17,"taskProducer"],[44,31,43,29],[44,32,43,30],[44,33,43,31],[45,6,44,4],[45,10,44,8,"buffer"],[45,16,44,14],[45,17,44,15,"indexOf"],[45,24,44,22],[45,25,44,23,"task"],[45,29,44,27],[45,30,44,28],[45,35,44,33],[45,36,44,34],[45,37,44,35],[45,39,44,37],[46,8,45,6,"buffer"],[46,14,45,12],[46,15,45,13,"push"],[46,19,45,17],[46,20,45,18,"task"],[46,24,45,22],[46,25,45,23],[47,6,46,4],[48,6,47,4],[48,11,47,9,"task"],[48,15,47,13],[48,16,48,7,"then"],[48,20,48,11],[48,21,48,12],[48,27,48,18,"remove"],[48,33,48,24],[48,34,48,25,"task"],[48,38,48,29],[48,39,48,30],[49,6,49,6],[50,6,50,6],[51,6,51,6],[52,6,51,6],[52,7,52,7,"then"],[52,11,52,11],[52,12,52,12],[52,16,52,16],[52,18,52,18],[52,24,53,8,"remove"],[52,30,53,14],[52,31,53,15,"task"],[52,35,53,19],[52,36,53,20],[52,37,53,21,"then"],[52,41,53,25],[52,42,53,26],[52,46,53,30],[52,48,53,32],[52,54,53,38],[53,8,54,10],[54,6,54,10],[54,7,55,9],[54,8,56,6],[54,9,56,7],[55,6,57,4],[55,13,57,11,"task"],[55,17,57,15],[56,4,58,2],[58,4,60,2],[59,0,61,0],[60,0,62,0],[61,0,63,0],[62,0,64,0],[63,0,65,0],[64,0,66,0],[65,0,67,0],[66,0,68,0],[67,4,69,2],[67,13,69,11,"drain"],[67,18,69,16,"drain"],[67,19,69,17,"timeout"],[67,26,69,24],[67,28,69,26],[68,6,70,4],[68,13,70,11],[68,17,70,15,"syncpromise"],[68,28,70,26],[68,29,70,27,"SyncPromise"],[68,40,70,38],[68,41,70,39],[68,42,70,40,"resolve"],[68,49,70,47],[68,51,70,49,"reject"],[68,57,70,55],[68,62,70,60],[69,8,71,6],[69,12,71,10,"counter"],[69,19,71,17],[69,22,71,20,"buffer"],[69,28,71,26],[69,29,71,27,"length"],[69,35,71,33],[70,8,73,6],[70,12,73,10],[70,13,73,11,"counter"],[70,20,73,18],[70,22,73,20],[71,10,74,8],[71,17,74,15,"resolve"],[71,24,74,22],[71,25,74,23],[71,29,74,27],[71,30,74,28],[72,8,75,6],[74,8,77,6],[75,8,78,6],[75,14,78,12,"capturedSetTimeout"],[75,32,78,30],[75,35,78,33,"setTimeout"],[75,45,78,43],[75,46,78,44],[75,52,78,50],[76,10,79,8],[76,14,79,12,"timeout"],[76,21,79,19],[76,25,79,23,"timeout"],[76,32,79,30],[76,35,79,33],[76,36,79,34],[76,38,79,36],[77,12,80,10,"resolve"],[77,19,80,17],[77,20,80,18],[77,25,80,23],[77,26,80,24],[78,10,81,8],[79,8,82,6],[79,9,82,7],[79,11,82,9,"timeout"],[79,18,82,16],[79,19,82,17],[81,8,84,6],[82,8,85,6,"buffer"],[82,14,85,12],[82,15,85,13,"forEach"],[82,22,85,20],[82,23,85,21,"item"],[82,27,85,25],[82,31,85,29],[83,10,86,8],[83,15,86,13,"syncpromise"],[83,26,86,24],[83,27,86,25,"resolvedSyncPromise"],[83,46,86,44],[83,47,86,45,"item"],[83,51,86,49],[83,52,86,50],[83,53,86,51,"then"],[83,57,86,55],[83,58,86,56],[83,64,86,62],[84,12,87,10],[84,16,87,14],[84,17,87,15],[84,20,87,17,"counter"],[84,27,87,24],[84,29,87,26],[85,14,88,12,"clearTimeout"],[85,26,88,24],[85,27,88,25,"capturedSetTimeout"],[85,45,88,43],[85,46,88,44],[86,14,89,12,"resolve"],[86,21,89,19],[86,22,89,20],[86,26,89,24],[86,27,89,25],[87,12,90,10],[88,10,91,8],[88,11,91,9],[88,13,91,11,"reject"],[88,19,91,17],[88,20,91,18],[89,8,92,6],[89,9,92,7],[89,10,92,8],[90,6,93,4],[90,7,93,5],[90,8,93,6],[91,4,94,2],[92,4,96,2],[92,11,96,9],[93,6,97,4,"$"],[93,7,97,5],[93,9,97,7,"buffer"],[93,15,97,13],[94,6,98,4,"add"],[94,9,98,7],[95,6,99,4,"drain"],[96,4,100,2],[96,5,100,3],[97,2,101,0],[98,2,103,0,"exports"],[98,9,103,7],[98,10,103,8,"makePromiseBuffer"],[98,27,103,25],[98,30,103,28,"makePromiseBuffer"],[98,47,103,45],[99,0,103,46],[99,3]],"functionMap":{"names":["<global>","makePromiseBuffer","isReady","remove","add","task.then$argument_0","task.then.then$argument_1","remove.then$argument_1","drain","syncpromise.SyncPromise$argument_0","setTimeout$argument_0","buffer.forEach$argument_0","syncpromise.resolvedSyncPromise.then$argument_0"],"mappings":"AAA;ACS;ECG;GDE;EEQ;GFE;EGY;YCW,kBD;kBEI;gCCC;SDE,CF;GHG;EOW;uCCC;4CCQ;ODI;qBEG;wDCC;SDK;OFC;KDC;GPC;CDO"},"hasCjsExports":true},"type":"js/module"}]}