{"dependencies":[{"name":"./error.js","data":{"asyncType":null,"isESMImport":true,"locs":[{"start":{"line":1,"column":0,"index":0},"end":{"line":1,"column":41,"index":41}}],"key":"ycPOBQoRsCJSxLowwoXjlScYLNE=","exportNames":["*"],"imports":1}},{"name":"./syncpromise.js","data":{"asyncType":null,"isESMImport":true,"locs":[{"start":{"line":2,"column":0,"index":42},"end":{"line":2,"column":89,"index":131}}],"key":"r9D+KVM39qpXh7dXewX99qgTA/A=","exportNames":["*"],"imports":1}}],"output":[{"data":{"code":"__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {\n  \"use strict\";\n\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n  Object.defineProperty(exports, \"makePromiseBuffer\", {\n    enumerable: true,\n    get: function () {\n      return makePromiseBuffer;\n    }\n  });\n  var _errorJs = require(_dependencyMap[0], \"./error.js\");\n  var _syncpromiseJs = require(_dependencyMap[1], \"./syncpromise.js\");\n  /**\n   * Creates an new PromiseBuffer object with the specified limit\n   * @param limit max number of promises that can be stored in the buffer\n   */\n  function makePromiseBuffer(limit) {\n    const buffer = [];\n    function isReady() {\n      return limit === undefined || buffer.length < limit;\n    }\n\n    /**\n     * Remove a promise from the queue.\n     *\n     * @param task Can be any PromiseLike<T>\n     * @returns Removed promise.\n     */\n    function remove(task) {\n      return buffer.splice(buffer.indexOf(task), 1)[0];\n    }\n\n    /**\n     * Add a promise (representing an in-flight action) to the queue, and set it to remove itself on fulfillment.\n     *\n     * @param taskProducer A function producing any PromiseLike<T>; In previous versions this used to be `task:\n     *        PromiseLike<T>`, but under that model, Promises were instantly created on the call-site and their executor\n     *        functions therefore ran immediately. Thus, even if the buffer was full, the action still happened. By\n     *        requiring the promise to be wrapped in a function, we can defer promise creation until after the buffer\n     *        limit check.\n     * @returns The original promise.\n     */\n    function add(taskProducer) {\n      if (!isReady()) {\n        return (0, _syncpromiseJs.rejectedSyncPromise)(new _errorJs.SentryError('Not adding Promise because buffer limit was reached.'));\n      }\n\n      // start the task and add its promise to the queue\n      const task = taskProducer();\n      if (buffer.indexOf(task) === -1) {\n        buffer.push(task);\n      }\n      void task.then(() => remove(task))\n      // Use `then(null, rejectionHandler)` rather than `catch(rejectionHandler)` so that we can use `PromiseLike`\n      // rather than `Promise`. `PromiseLike` doesn't have a `.catch` method, making its polyfill smaller. (ES5 didn't\n      // have promises, so TS has to polyfill when down-compiling.)\n      .then(null, () => remove(task).then(null, () => {\n        // We have to add another catch here because `remove()` starts a new promise chain.\n      }));\n      return task;\n    }\n\n    /**\n     * Wait for all promises in the queue to resolve or for timeout to expire, whichever comes first.\n     *\n     * @param timeout The time, in ms, after which to resolve to `false` if the queue is still non-empty. Passing `0` (or\n     * not passing anything) will make the promise wait as long as it takes for the queue to drain before resolving to\n     * `true`.\n     * @returns A promise which will resolve to `true` if the queue is already empty or drains before the timeout, and\n     * `false` otherwise\n     */\n    function drain(timeout) {\n      return new _syncpromiseJs.SyncPromise((resolve, reject) => {\n        let counter = buffer.length;\n        if (!counter) {\n          return resolve(true);\n        }\n\n        // wait for `timeout` ms and then resolve to `false` (if not cancelled first)\n        const capturedSetTimeout = setTimeout(() => {\n          if (timeout && timeout > 0) {\n            resolve(false);\n          }\n        }, timeout);\n\n        // if all promises resolve in time, cancel the timer and resolve to `true`\n        buffer.forEach(item => {\n          void (0, _syncpromiseJs.resolvedSyncPromise)(item).then(() => {\n            if (! --counter) {\n              clearTimeout(capturedSetTimeout);\n              resolve(true);\n            }\n          }, reject);\n        });\n      });\n    }\n    return {\n      $: buffer,\n      add,\n      drain\n    };\n  }\n});","lineCount":105,"map":[[7,2,101,0,"Object"],[7,8,101,0],[7,9,101,0,"defineProperty"],[7,23,101,0],[7,24,101,0,"exports"],[7,31,101,0],[8,4,101,0,"enumerable"],[8,14,101,0],[9,4,101,0,"get"],[9,7,101,0],[9,18,101,0,"get"],[9,19,101,0],[10,6,101,0],[10,13,101,9,"makePromiseBuffer"],[10,30,101,26],[11,4,101,26],[12,2,101,26],[13,2,1,0],[13,6,1,0,"_errorJs"],[13,14,1,0],[13,17,1,0,"require"],[13,24,1,0],[13,25,1,0,"_dependencyMap"],[13,39,1,0],[14,2,2,0],[14,6,2,0,"_syncpromiseJs"],[14,20,2,0],[14,23,2,0,"require"],[14,30,2,0],[14,31,2,0,"_dependencyMap"],[14,45,2,0],[15,2,4,0],[16,0,5,0],[17,0,6,0],[18,0,7,0],[19,2,8,0],[19,11,8,9,"makePromiseBuffer"],[19,28,8,26,"makePromiseBuffer"],[19,29,8,27,"limit"],[19,34,8,32],[19,36,8,34],[20,4,9,2],[20,10,9,8,"buffer"],[20,16,9,14],[20,19,9,17],[20,21,9,19],[21,4,11,2],[21,13,11,11,"isReady"],[21,20,11,18,"isReady"],[21,21,11,18],[21,23,11,21],[22,6,12,4],[22,13,12,11,"limit"],[22,18,12,16],[22,23,12,21,"undefined"],[22,32,12,30],[22,36,12,34,"buffer"],[22,42,12,40],[22,43,12,41,"length"],[22,49,12,47],[22,52,12,50,"limit"],[22,57,12,55],[23,4,13,2],[25,4,15,2],[26,0,16,0],[27,0,17,0],[28,0,18,0],[29,0,19,0],[30,0,20,0],[31,4,21,2],[31,13,21,11,"remove"],[31,19,21,17,"remove"],[31,20,21,18,"task"],[31,24,21,22],[31,26,21,24],[32,6,22,4],[32,13,22,11,"buffer"],[32,19,22,17],[32,20,22,18,"splice"],[32,26,22,24],[32,27,22,25,"buffer"],[32,33,22,31],[32,34,22,32,"indexOf"],[32,41,22,39],[32,42,22,40,"task"],[32,46,22,44],[32,47,22,45],[32,49,22,47],[32,50,22,48],[32,51,22,49],[32,52,22,50],[32,53,22,51],[32,54,22,52],[33,4,23,2],[35,4,25,2],[36,0,26,0],[37,0,27,0],[38,0,28,0],[39,0,29,0],[40,0,30,0],[41,0,31,0],[42,0,32,0],[43,0,33,0],[44,0,34,0],[45,4,35,2],[45,13,35,11,"add"],[45,16,35,14,"add"],[45,17,35,15,"taskProducer"],[45,29,35,27],[45,31,35,29],[46,6,36,4],[46,10,36,8],[46,11,36,9,"isReady"],[46,18,36,16],[46,19,36,17],[46,20,36,18],[46,22,36,20],[47,8,37,6],[47,15,37,13],[47,19,37,13,"rejectedSyncPromise"],[47,33,37,32],[47,34,37,32,"rejectedSyncPromise"],[47,53,37,32],[47,55,37,33],[47,59,37,37,"SentryError"],[47,67,37,48],[47,68,37,48,"SentryError"],[47,79,37,48],[47,80,37,49],[47,134,37,103],[47,135,37,104],[47,136,37,105],[48,6,38,4],[50,6,40,4],[51,6,41,4],[51,12,41,10,"task"],[51,16,41,14],[51,19,41,17,"taskProducer"],[51,31,41,29],[51,32,41,30],[51,33,41,31],[52,6,42,4],[52,10,42,8,"buffer"],[52,16,42,14],[52,17,42,15,"indexOf"],[52,24,42,22],[52,25,42,23,"task"],[52,29,42,27],[52,30,42,28],[52,35,42,33],[52,36,42,34],[52,37,42,35],[52,39,42,37],[53,8,43,6,"buffer"],[53,14,43,12],[53,15,43,13,"push"],[53,19,43,17],[53,20,43,18,"task"],[53,24,43,22],[53,25,43,23],[54,6,44,4],[55,6,45,4],[55,11,45,9,"task"],[55,15,45,13],[55,16,46,7,"then"],[55,20,46,11],[55,21,46,12],[55,27,46,18,"remove"],[55,33,46,24],[55,34,46,25,"task"],[55,38,46,29],[55,39,46,30],[56,6,47,6],[57,6,48,6],[58,6,49,6],[59,6,49,6],[59,7,50,7,"then"],[59,11,50,11],[59,12,50,12],[59,16,50,16],[59,18,50,18],[59,24,51,8,"remove"],[59,30,51,14],[59,31,51,15,"task"],[59,35,51,19],[59,36,51,20],[59,37,51,21,"then"],[59,41,51,25],[59,42,51,26],[59,46,51,30],[59,48,51,32],[59,54,51,38],[60,8,52,10],[61,6,52,10],[61,7,53,9],[61,8,54,6],[61,9,54,7],[62,6,55,4],[62,13,55,11,"task"],[62,17,55,15],[63,4,56,2],[65,4,58,2],[66,0,59,0],[67,0,60,0],[68,0,61,0],[69,0,62,0],[70,0,63,0],[71,0,64,0],[72,0,65,0],[73,0,66,0],[74,4,67,2],[74,13,67,11,"drain"],[74,18,67,16,"drain"],[74,19,67,17,"timeout"],[74,26,67,24],[74,28,67,26],[75,6,68,4],[75,13,68,11],[75,17,68,15,"SyncPromise"],[75,31,68,26],[75,32,68,26,"SyncPromise"],[75,43,68,26],[75,44,68,27],[75,45,68,28,"resolve"],[75,52,68,35],[75,54,68,37,"reject"],[75,60,68,43],[75,65,68,48],[76,8,69,6],[76,12,69,10,"counter"],[76,19,69,17],[76,22,69,20,"buffer"],[76,28,69,26],[76,29,69,27,"length"],[76,35,69,33],[77,8,71,6],[77,12,71,10],[77,13,71,11,"counter"],[77,20,71,18],[77,22,71,20],[78,10,72,8],[78,17,72,15,"resolve"],[78,24,72,22],[78,25,72,23],[78,29,72,27],[78,30,72,28],[79,8,73,6],[81,8,75,6],[82,8,76,6],[82,14,76,12,"capturedSetTimeout"],[82,32,76,30],[82,35,76,33,"setTimeout"],[82,45,76,43],[82,46,76,44],[82,52,76,50],[83,10,77,8],[83,14,77,12,"timeout"],[83,21,77,19],[83,25,77,23,"timeout"],[83,32,77,30],[83,35,77,33],[83,36,77,34],[83,38,77,36],[84,12,78,10,"resolve"],[84,19,78,17],[84,20,78,18],[84,25,78,23],[84,26,78,24],[85,10,79,8],[86,8,80,6],[86,9,80,7],[86,11,80,9,"timeout"],[86,18,80,16],[86,19,80,17],[88,8,82,6],[89,8,83,6,"buffer"],[89,14,83,12],[89,15,83,13,"forEach"],[89,22,83,20],[89,23,83,21,"item"],[89,27,83,25],[89,31,83,29],[90,10,84,8],[90,15,84,13],[90,19,84,13,"resolvedSyncPromise"],[90,33,84,32],[90,34,84,32,"resolvedSyncPromise"],[90,53,84,32],[90,55,84,33,"item"],[90,59,84,37],[90,60,84,38],[90,61,84,39,"then"],[90,65,84,43],[90,66,84,44],[90,72,84,50],[91,12,85,10],[91,16,85,14],[91,17,85,15],[91,20,85,17,"counter"],[91,27,85,24],[91,29,85,26],[92,14,86,12,"clearTimeout"],[92,26,86,24],[92,27,86,25,"capturedSetTimeout"],[92,45,86,43],[92,46,86,44],[93,14,87,12,"resolve"],[93,21,87,19],[93,22,87,20],[93,26,87,24],[93,27,87,25],[94,12,88,10],[95,10,89,8],[95,11,89,9],[95,13,89,11,"reject"],[95,19,89,17],[95,20,89,18],[96,8,90,6],[96,9,90,7],[96,10,90,8],[97,6,91,4],[97,7,91,5],[97,8,91,6],[98,4,92,2],[99,4,94,2],[99,11,94,9],[100,6,95,4,"$"],[100,7,95,5],[100,9,95,7,"buffer"],[100,15,95,13],[101,6,96,4,"add"],[101,9,96,7],[102,6,97,4,"drain"],[103,4,98,2],[103,5,98,3],[104,2,99,0],[105,0,99,1],[105,3]],"functionMap":{"names":["<global>","makePromiseBuffer","isReady","remove","add","task.then$argument_0","task.then.then$argument_1","remove.then$argument_1","drain","SyncPromise$argument_0","setTimeout$argument_0","buffer.forEach$argument_0","resolvedSyncPromise.then$argument_0"],"mappings":"AAA;ACO;ECG;GDE;EEQ;GFE;EGY;YCW,kBD;kBEI;gCCC;SDE,CF;GHG;EOW;2BCC;4CCQ;ODI;qBEG;4CCC;SDK;OFC;KDC;GPC;CDO"},"hasCjsExports":false},"type":"js/module"}]}